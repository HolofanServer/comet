# èµ·å‹•ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£

## C.O.M.E.T.ã«ã¤ã„ã¦

**C.O.M.E.T.**ã®åå‰ã¯ä»¥ä¸‹ã®é ­æ–‡å­—ã‹ã‚‰æ§‹æˆã•ã‚Œã¦ã„ã¾ã™ï¼š

- **C**ommunity of
- **O**shilove
- **M**oderation &
- **E**njoyment
- **T**ogether

HFS - ãƒ›ãƒ­ãƒ©ã‚¤ãƒ–éå…¬å¼ãƒ•ã‚¡ãƒ³ã‚µãƒ¼ãƒãƒ¼ã®ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ã‚’æ”¯ãˆã‚‹ã€æ¨ã—æ„›ã¨ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã€ãã—ã¦æ¥½ã—ã•ã‚’ä¸€ç·’ã«æä¾›ã™ã‚‹ãƒœãƒƒãƒˆã§ã™ã€‚

## æ¦‚è¦

COMETãƒœãƒƒãƒˆã®èµ·å‹•ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã¯ã€ãƒœãƒƒãƒˆã®åˆæœŸåŒ–ãƒ—ãƒ­ã‚»ã‚¹ã‚’æ”¯æ´ã—ã€ã‚·ã‚¹ãƒ†ãƒ ã®å¥å…¨æ€§ãƒã‚§ãƒƒã‚¯ã€ä¾å­˜é–¢ä¿‚ã®ç¢ºèªã€ç’°å¢ƒè¨­å®šã®æ¤œè¨¼ã‚’è¡Œã„ã¾ã™ã€‚å®‰å…¨ã§ç¢ºå®Ÿãªèµ·å‹•ã‚’ä¿è¨¼ã™ã‚‹ãŸã‚ã®åŒ…æ‹¬çš„ãªãƒ„ãƒ¼ãƒ«ã‚»ãƒƒãƒˆã‚’æä¾›ã—ã¾ã™ã€‚

## èµ·å‹•ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                èµ·å‹•ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  åˆæœŸåŒ–ç®¡ç†å±¤ (Initialization Management)                   â”‚
â”‚  â”œâ”€â”€ èµ·å‹•ã‚·ãƒ¼ã‚±ãƒ³ã‚¹åˆ¶å¾¡                                      â”‚
â”‚  â”œâ”€â”€ ä¾å­˜é–¢ä¿‚ãƒã‚§ãƒƒã‚¯                                        â”‚
â”‚  â”œâ”€â”€ ç’°å¢ƒæ¤œè¨¼                                                â”‚
â”‚  â””â”€â”€ è¨­å®šèª­ã¿è¾¼ã¿                                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ã‚·ã‚¹ãƒ†ãƒ ãƒã‚§ãƒƒã‚¯å±¤ (System Check)                          â”‚
â”‚  â”œâ”€â”€ ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢è¦ä»¶ç¢ºèª                                    â”‚
â”‚  â”œâ”€â”€ ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ä¾å­˜é–¢ä¿‚                                    â”‚
â”‚  â”œâ”€â”€ ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šæ€§                                      â”‚
â”‚  â””â”€â”€ æ¨©é™ç¢ºèª                                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ãƒ‡ãƒ¼ã‚¿æº–å‚™å±¤ (Data Preparation)                            â”‚
â”‚  â”œâ”€â”€ ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–                                      â”‚
â”‚  â”œâ”€â”€ ã‚­ãƒ£ãƒƒã‚·ãƒ¥æº–å‚™                                          â”‚
â”‚  â”œâ”€â”€ ãƒ•ã‚¡ã‚¤ãƒ«ã‚·ã‚¹ãƒ†ãƒ ç¢ºèª                                    â”‚
â”‚  â””â”€â”€ ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ç¢ºèª                                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ã‚µãƒ¼ãƒ“ã‚¹èµ·å‹•å±¤ (Service Startup)                           â”‚
â”‚  â”œâ”€â”€ ã‚³ã‚¢ã‚µãƒ¼ãƒ“ã‚¹èµ·å‹•                                        â”‚
â”‚  â”œâ”€â”€ å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹æ¥ç¶š                                        â”‚
â”‚  â”œâ”€â”€ ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ é–‹å§‹                                        â”‚
â”‚  â””â”€â”€ é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ èµ·å‹•                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## èµ·å‹•ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ç®¡ç†

### 1. èµ·å‹•ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼

```python
import asyncio
import sys
import os
import platform
import psutil
from typing import Dict, List, Optional, Callable, Any
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class StartupPhase:
    def __init__(self, name: str, description: str, handler: Callable, required: bool = True):
        self.name = name
        self.description = description
        self.handler = handler
        self.required = required
        self.completed = False
        self.error = None
        self.start_time = None
        self.end_time = None
        self.duration = None

class StartupManager:
    def __init__(self):
        self.phases = []
        self.startup_start_time = None
        self.startup_end_time = None
        self.total_duration = None
        self.failed_phases = []
        self.warnings = []
        
    def add_phase(self, name: str, description: str, handler: Callable, required: bool = True):
        """èµ·å‹•ãƒ•ã‚§ãƒ¼ã‚ºã®è¿½åŠ """
        phase = StartupPhase(name, description, handler, required)
        self.phases.append(phase)
        logger.debug(f"Added startup phase: {name}")
    
    async def execute_startup(self) -> bool:
        """èµ·å‹•ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å®Ÿè¡Œ"""
        self.startup_start_time = datetime.now()
        logger.info("Starting COMET bot initialization sequence...")
        
        success = True
        
        for i, phase in enumerate(self.phases):
            logger.info(f"Phase {i+1}/{len(self.phases)}: {phase.description}")
            
            phase.start_time = datetime.now()
            
            try:
                result = await phase.handler()
                phase.completed = True
                phase.end_time = datetime.now()
                phase.duration = (phase.end_time - phase.start_time).total_seconds()
                
                if result is False and phase.required:
                    logger.error(f"Required phase '{phase.name}' failed")
                    phase.error = "Phase returned False"
                    self.failed_phases.append(phase)
                    success = False
                    break
                elif result is False:
                    logger.warning(f"Optional phase '{phase.name}' failed")
                    self.warnings.append(f"Optional phase '{phase.name}' failed")
                
                logger.info(f"âœ… {phase.name} completed in {phase.duration:.2f}s")
                
            except Exception as e:
                phase.error = str(e)
                phase.end_time = datetime.now()
                phase.duration = (phase.end_time - phase.start_time).total_seconds()
                
                logger.error(f"âŒ Phase '{phase.name}' failed: {e}")
                
                if phase.required:
                    self.failed_phases.append(phase)
                    success = False
                    break
                else:
                    self.warnings.append(f"Optional phase '{phase.name}' failed: {e}")
        
        self.startup_end_time = datetime.now()
        self.total_duration = (self.startup_end_time - self.startup_start_time).total_seconds()
        
        if success:
            logger.info(f"ğŸ‰ COMET bot initialization completed successfully in {self.total_duration:.2f}s")
        else:
            logger.error(f"ğŸ’¥ COMET bot initialization failed after {self.total_duration:.2f}s")
        
        return success
    
    def get_startup_report(self) -> Dict[str, Any]:
        """èµ·å‹•ãƒ¬ãƒãƒ¼ãƒˆã®ç”Ÿæˆ"""
        completed_phases = [p for p in self.phases if p.completed]
        
        return {
            "success": len(self.failed_phases) == 0,
            "total_duration": self.total_duration,
            "total_phases": len(self.phases),
            "completed_phases": len(completed_phases),
            "failed_phases": len(self.failed_phases),
            "warnings": len(self.warnings),
            "phase_details": [
                {
                    "name": p.name,
                    "description": p.description,
                    "completed": p.completed,
                    "required": p.required,
                    "duration": p.duration,
                    "error": p.error
                }
                for p in self.phases
            ],
            "failed_phase_details": [
                {
                    "name": p.name,
                    "error": p.error,
                    "required": p.required
                }
                for p in self.failed_phases
            ],
            "warnings": self.warnings,
            "start_time": self.startup_start_time,
            "end_time": self.startup_end_time
        }
```

### 2. ã‚·ã‚¹ãƒ†ãƒ è¦ä»¶ãƒã‚§ãƒƒã‚¯

```python
class SystemRequirementsChecker:
    def __init__(self):
        self.requirements = {
            "python_version": (3, 8),
            "memory_mb": 512,
            "disk_space_mb": 1024,
            "required_packages": [
                "discord.py", "aiohttp", "asyncio", "logging"
            ]
        }
    
    async def check_python_version(self) -> bool:
        """Python ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã®ç¢ºèª"""
        current_version = sys.version_info[:2]
        required_version = self.requirements["python_version"]
        
        if current_version >= required_version:
            logger.info(f"âœ… Python version: {'.'.join(map(str, current_version))}")
            return True
        else:
            logger.error(f"âŒ Python version {'.'.join(map(str, required_version))} or higher required, got {'.'.join(map(str, current_version))}")
            return False
    
    async def check_system_resources(self) -> bool:
        """ã‚·ã‚¹ãƒ†ãƒ ãƒªã‚½ãƒ¼ã‚¹ã®ç¢ºèª"""
        try:
            memory = psutil.virtual_memory()
            available_mb = memory.available / 1024 / 1024
            required_mb = self.requirements["memory_mb"]
            
            if available_mb < required_mb:
                logger.error(f"âŒ Insufficient memory: {available_mb:.0f}MB available, {required_mb}MB required")
                return False
            
            logger.info(f"âœ… Memory: {available_mb:.0f}MB available")
            
            disk = psutil.disk_usage('.')
            available_disk_mb = disk.free / 1024 / 1024
            required_disk_mb = self.requirements["disk_space_mb"]
            
            if available_disk_mb < required_disk_mb:
                logger.error(f"âŒ Insufficient disk space: {available_disk_mb:.0f}MB available, {required_disk_mb}MB required")
                return False
            
            logger.info(f"âœ… Disk space: {available_disk_mb:.0f}MB available")
            
            return True
            
        except Exception as e:
            logger.error(f"âŒ Failed to check system resources: {e}")
            return False
    
    async def check_required_packages(self) -> bool:
        """å¿…é ˆãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã®ç¢ºèª"""
        missing_packages = []
        
        for package in self.requirements["required_packages"]:
            try:
                __import__(package.replace("-", "_"))
                logger.debug(f"âœ… Package found: {package}")
            except ImportError:
                missing_packages.append(package)
                logger.error(f"âŒ Missing package: {package}")
        
        if missing_packages:
            logger.error(f"âŒ Missing required packages: {', '.join(missing_packages)}")
            return False
        
        logger.info("âœ… All required packages are available")
        return True
```

### 3. ç’°å¢ƒè¨­å®šæ¤œè¨¼

```python
class EnvironmentValidator:
    def __init__(self):
        self.required_env_vars = [
            "BOT_TOKEN",
            "ADMIN_MAIN_GUILD_ID",
            "ADMIN_DEV_GUILD_ID"
        ]
        self.optional_env_vars = [
            "OPENAI_API_KEY",
            "UPTIME_KUMA_URL",
            "WEBHOOK_URL"
        ]
    
    async def validate_environment_variables(self) -> bool:
        """ç’°å¢ƒå¤‰æ•°ã®æ¤œè¨¼"""
        missing_required = []
        missing_optional = []
        
        for var in self.required_env_vars:
            value = os.getenv(var)
            if not value:
                missing_required.append(var)
            else:
                if not self._validate_env_var_value(var, value):
                    missing_required.append(f"{var} (invalid format)")
                else:
                    logger.debug(f"âœ… Environment variable: {var}")
        
        for var in self.optional_env_vars:
            value = os.getenv(var)
            if not value:
                missing_optional.append(var)
            else:
                logger.debug(f"âœ… Optional environment variable: {var}")
        
        if missing_required:
            logger.error(f"âŒ Missing required environment variables: {', '.join(missing_required)}")
            return False
        
        if missing_optional:
            logger.warning(f"âš ï¸ Missing optional environment variables: {', '.join(missing_optional)}")
        
        logger.info("âœ… Environment variables validation passed")
        return True
    
    def _validate_env_var_value(self, var_name: str, value: str) -> bool:
        """ç’°å¢ƒå¤‰æ•°å€¤ã®æ¤œè¨¼"""
        if var_name == "BOT_TOKEN":
            return len(value) > 50 and "." in value
        elif var_name.endswith("_GUILD_ID") or var_name.endswith("_CHANNEL_ID"):
            try:
                int(value)
                return len(value) >= 17
            except ValueError:
                return False
        elif var_name.endswith("_URL"):
            return value.startswith(("http://", "https://"))
        
        return True
```

---

## é–¢é€£ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ

- [ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•ãƒ•ãƒ­ãƒ¼](../01-architecture/02-application-startup-flow.md)
- [è¨­å®šç®¡ç†](../01-architecture/04-configuration-management.md)
- [ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ç®¡ç†](01-database-management.md)
- [ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°](../02-core/04-error-handling.md)
